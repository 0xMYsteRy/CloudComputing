{"ast":null,"code":"// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) {\n        // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n\n      return;\n    }\n\n    var proto = this.prototype || this,\n        pres = proto._pres = proto._pres || {},\n        posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this,\n          hookArgs // arguments eventually passed to the hook - are mutable\n      ,\n          lastArg = arguments[arguments.length - 1],\n          pres = this._pres[name],\n          posts = this._posts[name],\n          _total = pres.length,\n          _current = -1,\n          _asyncsLeft = proto[name].numAsyncPres,\n          _next = function () {\n        if (arguments[0] instanceof Error) {\n          return handleError(arguments[0]);\n        }\n\n        var _args = Array.prototype.slice.call(arguments),\n            currPre,\n            preArgs;\n\n        if (_args.length && !(arguments[0] == null && typeof lastArg === 'function')) hookArgs = _args;\n\n        if (++_current < _total) {\n          currPre = pres[_current];\n          if (currPre.isAsync && currPre.length < 2) throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n          if (currPre.length < 1) throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n          preArgs = (currPre.isAsync ? [once(_next), once(_asyncsDone)] : [once(_next)]).concat(hookArgs);\n          return currPre.apply(self, preArgs);\n        } else if (!proto[name].numAsyncPres) {\n          return _done.apply(self, hookArgs);\n        }\n      },\n          _done = function () {\n        var args_ = Array.prototype.slice.call(arguments),\n            ret,\n            total_,\n            current_,\n            next_,\n            done_,\n            postArgs;\n\n        if (_current === _total) {\n          next_ = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n\n            var args_ = Array.prototype.slice.call(arguments, 1),\n                currPost,\n                postArgs;\n            if (args_.length) hookArgs = args_;\n\n            if (++current_ < total_) {\n              currPost = posts[current_];\n              if (currPost.length < 1) throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n              postArgs = [once(next_)].concat(hookArgs);\n              return currPost.apply(self, postArgs);\n            } else if (typeof lastArg === 'function') {\n              // All post handlers are done, call original callback function\n              return lastArg.apply(self, arguments);\n            }\n          }; // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n          // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n\n\n          if (typeof lastArg === 'function') {\n            args_[args_.length - 1] = once(next_);\n          }\n\n          total_ = posts.length;\n          current_ = -1;\n          ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n          if (total_ && typeof lastArg !== 'function') return next_(); // no callback provided, execute next_() manually\n\n          return ret;\n        }\n      };\n\n      if (_asyncsLeft) {\n        function _asyncsDone(err) {\n          if (err && err instanceof Error) {\n            return handleError(err);\n          }\n\n          --_asyncsLeft || _done.apply(self, hookArgs);\n        }\n      }\n\n      function handleError(err) {\n        if ('function' == typeof lastArg) return lastArg(err);\n        if (errorCb) return errorCb.call(self, err);\n        throw err;\n      }\n\n      return _next.apply(this, arguments);\n    };\n\n    proto[name].numAsyncPres = 0;\n    return this;\n  },\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n\n    var proto = this.prototype || this,\n        pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n\n    var proto = this.prototype || this,\n        posts = proto._posts = proto._posts || {};\n\n    this._lazySetupHooks(proto, name);\n\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this,\n        pres = proto._pres || proto._pres || {};\n    if (!pres[name]) return this;\n\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter(function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n\n    return this;\n  },\n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once(fn, scope) {\n  return function fnWrapper() {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    return fn.apply(scope, arguments);\n  };\n}","map":{"version":3,"sources":["/Users/mystery/Desktop/bookstore-v2/node_modules/hooks/hooks.js"],"names":["module","exports","hook","name","fn","errorCb","arguments","length","k","proto","prototype","pres","_pres","posts","_posts","self","hookArgs","lastArg","_total","_current","_asyncsLeft","numAsyncPres","_next","Error","handleError","_args","Array","slice","call","currPre","preArgs","isAsync","once","_asyncsDone","concat","apply","_done","args_","ret","total_","current_","next_","done_","postArgs","currPost","err","pre","_lazySetupHooks","push","post","removePre","fnToRemove","filter","currFn","methodName","scope","fnWrapper","hookCalled"],"mappings":"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","sourcesContent":["// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!proto[name].numAsyncPres) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n      if (_asyncsLeft) {\n        function _asyncsDone (err) {\n          if (err && err instanceof Error) {\n            return handleError(err);\n          }\n          --_asyncsLeft || _done.apply(self, hookArgs);\n        }\n      }\n      function handleError (err) {\n        if ('function' == typeof lastArg)\n          return lastArg(err);\n        if (errorCb) return errorCb.call(self, err);\n        throw err;\n      }\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    return fn.apply(scope, arguments);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}